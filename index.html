<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dynamic Classroom Schedule</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
th { background: #f0f0f0; }
tr.locked { background: #eee; color: #888; }
tr.conflict { background: #fdd; }
tr.past { background: #f3f3f3; color: #aaa; }
tr.dragging { opacity: 0.5; }
tr#currentTimeRow { background: #d0f0ff; color: #000; font-weight: bold; }
input { width: 60px; text-align:center; }
button { padding: 8px 12px; margin-right: 10px; }
</style>
</head>
<body>

<h1>Dynamic Classroom Schedule</h1>

<label><input type="checkbox" id="templateMakerMode"> Free Edit Mode</label>
<br><br>

<label>Template: 
<select id="templateSelect"></select>
<button id="loadTemplate">Load</button>
<button id="saveTemplate">Save Current</button>
<input type="file" id="importFile">
<button id="exportTemplate">Export</button>
</label>

<table id="scheduleTable">
  <thead>
    <tr><th>Activity</th><th>Start Time</th><th>Duration (min)</th><th>Priority</th><th>Lock</th></tr>
  </thead>
  <tbody></tbody>
</table>

<button id="solveBtn">Solve Schedule</button>
<button id="resetBtn">Reset to Default</button>
<button id="undoBtn">Undo</button>

<script>
// --- utils ---
window.utils = {
    deepCopy: obj => JSON.parse(JSON.stringify(obj)),
    minutesToTimeString: m => { const h=Math.floor(m/60), min=m%60; return `${h.toString().padStart(2,'0')}:${min.toString().padStart(2,'0')}`; },
    timeStringToMinutes: s => { const [h,m]=s.split(':').map(Number); return h*60+m; },
    clamp: (val,min,max)=>Math.min(Math.max(val,min),max)
};

// --- state ---
window.state = (function(){
    let currentSchedule=[], defaultSchedule=[], history=[];
    return {
        setDefaultSchedule: s=>{defaultSchedule=utils.deepCopy(s); currentSchedule=utils.deepCopy(s); history=[]; renderSchedule(currentSchedule);},
        getCurrentSchedule: ()=>utils.deepCopy(currentSchedule),
        setCurrentSchedule: s=>{history.push(utils.deepCopy(currentSchedule)); currentSchedule=utils.deepCopy(s); renderSchedule(currentSchedule);},
        resetToDefault: ()=>{currentSchedule=utils.deepCopy(defaultSchedule); history=[]; renderSchedule(currentSchedule);},
        undo: ()=>{ if(history.length>0){ currentSchedule=history.pop(); renderSchedule(currentSchedule);} }
    };
})();

// --- solver ---
window.solver.prioritySolve = function() {
    const schedule = window.state.getCurrentSchedule();
    const dayEnd = window.currentDayEnd || (schedule[schedule.length-1].start + schedule[schedule.length-1].duration);
    const now = getCurrentTimeMinutes();

    // Step 1: Start times are sequential
    for(let i=1;i<schedule.length;i++){
        const prev = schedule[i-1];
        const act = schedule[i];
        if(!act.locked && (act.start + act.duration > now || document.getElementById('templateMakerMode').checked)){
            act.start = prev.start + prev.duration;
        }
    }

    // Step 2: Calculate total adjustable time
    let fixedTime = 0;
    let flexibleActivities = [];
    schedule.forEach(act=>{
        if(act.locked || !act.flexible || (!document.getElementById('templateMakerMode').checked && act.start + act.duration <= now)){
            fixedTime += act.duration;
        } else {
            flexibleActivities.push(act);
        }
    });

    let remainingTime = dayEnd - fixedTime;
    let totalFlexibleMin = flexibleActivities.reduce((sum, a)=>sum + a.minDuration,0);
    let totalFlexibleMax = flexibleActivities.reduce((sum, a)=>sum + a.maxDuration,0);

    // Step 3: Check if remainingTime fits within flexible ranges
    if(remainingTime < totalFlexibleMin){
        alert("Cannot fit schedule within day: not enough time for minimum durations.");
        return;
    }
    if(remainingTime > totalFlexibleMax){
        alert("Cannot fit schedule within day: too much time for maximum durations.");
        return;
    }

    // Step 4: Distribute remaining time according to priorities
    // Start by giving minDuration to each flexible activity
    flexibleActivities.forEach(act => act.duration = act.minDuration);
    let extraTime = remainingTime - totalFlexibleMin;

    // Sort by priority (lower number = higher priority to change)
    flexibleActivities.sort((a,b)=>a.priority - b.priority);

    // Distribute extraTime to activities without exceeding maxDuration
    for(let act of flexibleActivities){
        if(extraTime <= 0) break;
        let room = act.maxDuration - act.duration;
        let add = Math.min(room, extraTime);
        act.duration += add;
        extraTime -= add;
    }

    // Step 5: Recalculate start times after duration adjustments
    for(let i=1;i<schedule.length;i++){
        schedule[i].start = schedule[i-1].start + schedule[i-1].duration;
    }

    window.state.setCurrentSchedule(schedule);
};

// --- template manager ---
function saveTemplate() {
    const name = prompt("Template name:");
    if(!name) return;

    const schedule = window.state.getCurrentSchedule();

    // Ask for day end time in HH:mm
    let dayEndStr = prompt("Enter day end time (HH:mm, e.g., 12:15):", utils.minutesToTimeString(schedule[schedule.length-1].start + schedule[schedule.length-1].duration));
    if(!dayEndStr) return;
    const dayEnd = utils.timeStringToMinutes(dayEndStr);

    const days = prompt("Enter weekdays for this template (comma separated, e.g., Monday,Wednesday):","");
    const special = prompt("Enter special cases for this template (comma separated, optional):","");

    const template = {
        name: name,
        dayEnd: dayEnd,
        activities: schedule,
        days: days ? days.split(',').map(d=>d.trim()) : [],
        special: special ? special.split(',').map(s=>s.trim()) : []
    };

    let templates = JSON.parse(localStorage.getItem('scheduleTemplates')) || [];
    templates.push(template);
    localStorage.setItem('scheduleTemplates', JSON.stringify(templates));
    refreshTemplateSelect();
}

function loadTemplate(index){
    const templates = JSON.parse(localStorage.getItem('scheduleTemplates')) || [];
    if(index < 0 || index >= templates.length) return;

    const t = templates[index];
    window.state.setDefaultSchedule(t.activities);
    window.currentDayEnd = t.dayEnd; // crucial for prioritySolve
}

function refreshTemplateSelect(){
    const select=document.getElementById('templateSelect');
    select.innerHTML='';
    const templates=JSON.parse(localStorage.getItem('scheduleTemplates'))||[];
    templates.forEach((t,i)=>{ const opt=document.createElement('option'); opt.value=i; opt.text=t.name; select.appendChild(opt); });
}
function exportTemplate(){
    const index=document.getElementById('templateSelect').value;
    const templates=JSON.parse(localStorage.getItem('scheduleTemplates'))||[];
    if(!templates[index]) return;
    const dataStr="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(templates[index]));
    const a=document.createElement('a'); a.href=dataStr; a.download=templates[index].name+".json";
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
}
function importTemplate(file){
    const reader=new FileReader();
    reader.onload=function(e){
        const t=JSON.parse(e.target.result);
        let templates=JSON.parse(localStorage.getItem('scheduleTemplates'))||[];
        templates.push(t); localStorage.setItem('scheduleTemplates', JSON.stringify(templates));
        refreshTemplateSelect();
    }
    reader.readAsText(file);
}

// --- automatic template selection ---
function autoLoadTemplate(){
    const templates = JSON.parse(localStorage.getItem('scheduleTemplates')) || [];
    const today = new Date().toLocaleDateString('en-US', { weekday: 'long' });
    const specialCases = []; // can be manually added or detected

    const matches = templates.filter(t => (t.days?.includes(today) || t.special?.some(s=>specialCases.includes(s))));

    if(matches.length === 0) return;
    if(matches.length === 1){
        window.state.setDefaultSchedule(matches[0].activities);
        window.currentDayEnd = matches[0].dayEnd;
        return;
    }

    const choice = prompt("Multiple templates match today:\n" + matches.map((t,i)=>`${i+1}: ${t.name}`).join("\n") + "\nEnter number:");
    const idx = parseInt(choice)-1;
    if(idx >= 0 && idx < matches.length) {
        window.state.setDefaultSchedule(matches[idx].activities);
        window.currentDayEnd = matches[idx].dayEnd;
    }
}


// --- helper: current time ---
function getCurrentTimeMinutes() {
    const now = new Date();
    return now.getHours() * 60 + now.getMinutes();
}

// --- default schedule ---
const defaultSchedule=[
    {name:'Arrival', start:480, duration:60, minDuration:50, maxDuration:70, flexible:true, priority:2, locked:false},
    {name:'Meeting', start:540, duration:30, minDuration:30, maxDuration:30, flexible:false, priority:5, locked:false},
    {name:'Playground', start:570, duration:60, minDuration:50, maxDuration:70, flexible:true, priority:1, locked:false},
    {name:'Play', start:630, duration:60, minDuration:60, maxDuration:60, flexible:false, priority:5, locked:false},
    {name:'Lunch', start:690, duration:30, minDuration:20, maxDuration:40, flexible:true, priority:2, locked:false},
    {name:'Goodbye', start:720, duration:15, minDuration:15, maxDuration:15, flexible:false, priority:5, locked:false}
];
window.state.setDefaultSchedule(defaultSchedule);

// --- current time indicator ---
function renderCurrentTimeIndicator() {
    const tbody = document.querySelector('#scheduleTable tbody');
    let timeRow = document.getElementById('currentTimeRow');
    const now = getCurrentTimeMinutes();
    
    if(timeRow) timeRow.remove();

    const schedule = window.state.getCurrentSchedule();
    let insertIndex = schedule.findIndex(act => act.start + act.duration > now);
    if(insertIndex === -1) insertIndex = schedule.length;

    timeRow = document.createElement('tr');
    timeRow.id = 'currentTimeRow';
    timeRow.innerHTML = `<td colspan="5">Current Time: ${utils.minutesToTimeString(now)}</td>`;

    const rows = tbody.querySelectorAll('tr');
    if(insertIndex < rows.length) {
        tbody.insertBefore(timeRow, rows[insertIndex]);
    } else {
        tbody.appendChild(timeRow);
    }
}

// --- rendering ---
function renderSchedule(schedule){
    const tbody=document.querySelector('#scheduleTable tbody');
    tbody.innerHTML='';
    const now = getCurrentTimeMinutes();
    const freeEditMode = document.getElementById('templateMakerMode').checked;

    schedule.forEach((act,i)=>{
        const row=document.createElement('tr');
        if(act.locked) row.classList.add('locked');
        if(!freeEditMode && act.start + act.duration <= now) row.classList.add('past');
        row.setAttribute('draggable',!act.locked && (freeEditMode || act.start + act.duration > now));
        row.dataset.index=i;
        row.innerHTML=`<td>${act.name}</td>
                       <td><input type="time" step="300" value="${utils.minutesToTimeString(act.start)}" data-index="${i}" class="start" ${(!freeEditMode && act.start + act.duration <= now ? 'disabled' : '')}></td>
                       <td><input type="number" step="5" min="${act.minDuration}" max="${act.maxDuration}" value="${act.duration}" data-index="${i}" class="duration" ${(!act.flexible && !freeEditMode ? 'disabled' : '')}></td>
                       <td><input type="number" step="1" min="1" max="5" value="${act.priority}" data-index="${i}" class="priority" ${(!freeEditMode && act.start + act.duration <= now ? 'disabled' : '')}></td>
                       <td><input type="checkbox" ${act.locked?'checked':''} data-index="${i}" class="lock" ${(!freeEditMode && act.start + act.duration <= now ? 'disabled' : '')}></td>`;
        tbody.appendChild(row);
    });

    renderCurrentTimeIndicator();

    // --- input listeners ---
    document.querySelectorAll('.start').forEach(input=>{
        input.addEventListener('change', e=>{
            const i=parseInt(e.target.dataset.index), val=utils.timeStringToMinutes(e.target.value);
            const schedule=window.state.getCurrentSchedule();
            if(!schedule[i].locked && (freeEditMode || schedule[i].start + schedule[i].duration > now)){
                schedule[i].start=val;
                window.state.setCurrentSchedule(schedule);
            }
        });
    });
    document.querySelectorAll('.duration').forEach(input=>{
        input.setAttribute('step','5');
        input.addEventListener('change', e=>{
            const i=parseInt(e.target.dataset.index);
            const schedule=window.state.getCurrentSchedule();
            if(!schedule[i].locked && (freeEditMode || schedule[i].flexible)){
                schedule[i].duration = utils.clamp(Math.round(parseInt(e.target.value)/5)*5, schedule[i].minDuration, schedule[i].maxDuration);
                e.target.value = schedule[i].duration;
                window.state.setCurrentSchedule(schedule);
            }
        });
    });
    document.querySelectorAll('.priority').forEach(input=>{
        input.addEventListener('change', e=>{
            const i=parseInt(e.target.dataset.index), val=parseInt(e.target.value);
            const schedule=window.state.getCurrentSchedule();
            schedule[i].priority=val;
            window.state.setCurrentSchedule(schedule);
        });
    });
    document.querySelectorAll('.lock').forEach(input=>{
        input.addEventListener('change', e=>{
            const i=parseInt(e.target.dataset.index);
            const schedule=window.state.getCurrentSchedule();
            schedule[i].locked=e.target.checked;
            window.state.setCurrentSchedule(schedule);
        });
    });

    // --- drag-and-drop ---
    let dragged=null;
    tbody.querySelectorAll('tr').forEach(row=>{
        row.addEventListener('dragstart', e=>{ dragged=row; row.classList.add('dragging'); });
        row.addEventListener('dragend', e=>{ dragged=null; row.classList.remove('dragging'); });
        row.addEventListener('dragover', e=>{ e.preventDefault(); });
        row.addEventListener('drop', e=>{
            e.preventDefault();
            if(dragged && dragged!==row){
                const schedule=window.state.getCurrentSchedule();
                const from=parseInt(dragged.dataset.index);
                const to=parseInt(row.dataset.index);
                const moved=schedule.splice(from,1)[0];
                schedule.splice(to,0,moved);
                schedule[0].start=schedule[0].start;
                for(let i=1;i<schedule.length;i++) schedule[i].start=schedule[i-1].start+schedule[i-1].duration;
                window.state.setCurrentSchedule(schedule);
            }
        });
    });
}

// --- initial render ---
refreshTemplateSelect();
autoLoadTemplate();
renderSchedule(window.state.getCurrentSchedule());
setInterval(renderCurrentTimeIndicator,60000);

// --- button handlers ---
document.getElementById('templateMakerMode').addEventListener('change', () => { renderSchedule(window.state.getCurrentSchedule()); });
document.getElementById('solveBtn').addEventListener('click', ()=>window.solver.prioritySolve());
document.getElementById('resetBtn').addEventListener('click', ()=>window.state.resetToDefault());
document.getElementById('undoBtn').addEventListener('click', ()=>window.state.undo());
document.getElementById('saveTemplate').addEventListener('click', saveTemplate);
document.getElementById('loadTemplate').addEventListener('click', ()=>loadTemplate(document.getElementById('templateSelect').value));
document.getElementById('exportTemplate').addEventListener('click', exportTemplate);
document.getElementById('importFile').addEventListener('change', e=>importTemplate(e.target.files[0]));

</script>
</body>
</html>
